![기본형1_java](https://github.com/user-attachments/assets/6ac5189b-a4bd-44ae-a4d4-306d6e777973)

## 구명보트

### 문제풀이

오늘은 탐욕법(Greedy)문제가 나왔다. 그리디도 마찬가지로 문제를 어떻게 푸는지 잘 알지 못해서 chatGPT한테 도움을 요청했는데 그래도 BFS/DFS보다는 훨씬 금방 풀겠다는 확신이 들었다. 비슷한 문제를 많이 접해보면 될 것 같다.

```java
import java.util.Arrays;

class Solution {
    public int solution(int[] people, int limit) {
        // 사람들의 몸무게를 오름차순으로 정렬
        Arrays.sort(people);
        
        int left = 0;  // 가장 가벼운 사람의 인덱스
        int right = people.length - 1;  // 가장 무거운 사람의 인덱스
        int answer = 0;  // 필요한 보트의 수

        // 투 포인터 방식으로 보트를 배정
        while (left <= right) {
            // 가장 가벼운 사람과 가장 무거운 사람의 합이 limit 이하이면 함께 태움
            if (people[left] + people[right] <= limit) {
                left++;  // 가장 가벼운 사람 태움
            }
            // 무거운 사람은 무조건 태워야 하므로 포인터 이동
            right--;  // 가장 무거운 사람 태움
            answer++;  // 보트 한 척 사용
        }
        
        return answer;  // 최소 보트 수 반환
    }
}
```


### 구명보트 문제 해결 방법(chatGPT)

1. 정렬하기
    - 사람들의 몸무게 배열을 오름차순으로 정렬합니다. 이렇게 하면 가장 가벼운 사람과 가장 무거운 사람을 쉽게 비교할 수 있습니다.

2. 투 포인터 사용하기

    - 두 개의 포인터를 사용합니다: 하나는 배열의 시작(가장 가벼운 사람)에서 시작하고, 다른 하나는 배열의 끝(가장 무거운 사람)에서 시작합니다.

    - left 포인터는 배열의 시작을 가리키고, right 포인터는 배열의 끝을 가리킵니다.

3. 탐색 및 조건 검토:

    - 가장 가벼운 사람(left)과 가장 무거운 사람(right)의 합이 보트의 최대 무게 제한을 넘지 않는다면, 둘을 함께 보트에 태울 수 있습니다. 이 경우, left와 right 모두를 움직입니다(left 증가, right 감소).

    - 두 사람의 무게 합이 보트의 최대 무게 제한을 초과한다면, 가장 무거운 사람(right)만 보트에 태우고 right 포인터를 한 칸 왼쪽으로 이동시킵니다.

    - 매 번 보트를 사용할 때마다 보트의 수를 하나씩 증가시킵니다.

4. 반복:

    - left 포인터가 right 포인터보다 작거나 같을 때까지 위의 과정을 반복합니다.

5. 보트 수 반환하기:

    - 모든 사람이 보트에 태워질 때까지의 보트 수를 반환합니다.

#### #99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
